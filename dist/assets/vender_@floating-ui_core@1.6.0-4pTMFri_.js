import{e,g as t,r as n,a,b as i,c as l,d as o,f as s,h as r,i as c,j as f,k as m,l as g,m as u,n as y}from"./vender_@floating-ui_utils@0.2.1-BjL72BsT.js";function d(e,t,n){let{reference:s,floating:r}=e;const c=l(t),f=o(t),m=g(f),u=a(t),y="y"===c,d=s.x+s.width/2-r.width/2,p=s.y+s.height/2-r.height/2,x=s[m]/2-r[m]/2;let w;switch(u){case"top":w={x:d,y:s.y-r.height};break;case"bottom":w={x:d,y:s.y+s.height};break;case"right":w={x:s.x+s.width,y:p};break;case"left":w={x:s.x-r.width,y:p};break;default:w={x:s.x,y:s.y}}switch(i(t)){case"start":w[f]-=x*(n&&y?-1:1);break;case"end":w[f]+=x*(n&&y?-1:1)}return w}const p=async(e,t,n)=>{const{placement:a="bottom",strategy:i="absolute",middleware:l=[],platform:o}=n,s=l.filter(Boolean),r=await(null==o.isRTL?void 0:o.isRTL(t));let c=await o.getElementRects({reference:e,floating:t,strategy:i}),{x:f,y:m}=d(c,a,r),g=a,u={},y=0;for(let p=0;p<s.length;p++){const{name:n,fn:l}=s[p],{x:x,y:w,data:v,reset:h}=await l({x:f,y:m,initialPlacement:a,placement:g,strategy:i,middlewareData:u,rects:c,platform:o,elements:{reference:e,floating:t}});f=null!=x?x:f,m=null!=w?w:m,u={...u,[n]:{...u[n],...v}},h&&y<=50&&(y++,"object"==typeof h&&(h.placement&&(g=h.placement),h.rects&&(c=!0===h.rects?await o.getElementRects({reference:e,floating:t,strategy:i}):h.rects),({x:f,y:m}=d(c,g,r))),p=-1)}return{x:f,y:m,placement:g,strategy:i,middlewareData:u}};async function x(a,i){var l;void 0===i&&(i={});const{x:o,y:s,platform:r,rects:c,elements:f,strategy:m}=a,{boundary:g="clippingAncestors",rootBoundary:u="viewport",elementContext:y="floating",altBoundary:d=!1,padding:p=0}=e(i,a),x=t(p),w=f[d?"floating"===y?"reference":"floating":y],v=n(await r.getClippingRect({element:null==(l=await(null==r.isElement?void 0:r.isElement(w)))||l?w:w.contextElement||await(null==r.getDocumentElement?void 0:r.getDocumentElement(f.floating)),boundary:g,rootBoundary:u,strategy:m})),h="floating"===y?{...c.floating,x:o,y:s}:c.reference,b=await(null==r.getOffsetParent?void 0:r.getOffsetParent(f.floating)),R=await(null==r.isElement?void 0:r.isElement(b))&&await(null==r.getScale?void 0:r.getScale(b))||{x:1,y:1},A=n(r.convertOffsetParentRelativeRectToViewportRelativeRect?await r.convertOffsetParentRelativeRectToViewportRelativeRect({elements:f,rect:h,offsetParent:b,strategy:m}):h);return{top:(v.top-A.top+x.top)/R.y,bottom:(A.bottom-v.bottom+x.bottom)/R.y,left:(v.left-A.left+x.left)/R.x,right:(A.right-v.right+x.right)/R.x}}const w=n=>({name:"arrow",options:n,async fn(a){const{x:l,y:s,placement:r,rects:c,platform:f,elements:y,middlewareData:d}=a,{element:p,padding:x=0}=e(n,a)||{};if(null==p)return{};const w=t(x),v={x:l,y:s},h=o(r),b=g(h),R=await f.getDimensions(p),A="y"===h,E=A?"top":"left",P=A?"bottom":"right",k=A?"clientHeight":"clientWidth",O=c.reference[b]+c.reference[h]-v[h]-c.floating[b],D=v[h]-c.reference[h],T=await(null==f.getOffsetParent?void 0:f.getOffsetParent(p));let L=T?T[k]:0;L&&await(null==f.isElement?void 0:f.isElement(T))||(L=y.floating[k]||c.floating[b]);const B=O/2-D/2,S=L/2-R[b]/2-1,j=u(w[E],S),C=u(w[P],S),F=j,V=L-R[b]-C,_=L/2-R[b]/2+B,H=m(F,_,V),W=!d.arrow&&null!=i(r)&&_!==H&&c.reference[b]/2-(_<F?j:C)-R[b]/2<0,q=W?_<F?_-F:_-V:0;return{[h]:v[h]+q,data:{[h]:H,centerOffset:_-H-q,...W&&{alignmentOffset:q}},reset:W}}}),v=function(t){return void 0===t&&(t={}),{name:"flip",options:t,async fn(n){var i,l;const{placement:o,middlewareData:m,rects:g,initialPlacement:u,platform:y,elements:d}=n,{mainAxis:p=!0,crossAxis:w=!0,fallbackPlacements:v,fallbackStrategy:h="bestFit",fallbackAxisSideDirection:b="none",flipAlignment:R=!0,...A}=e(t,n);if(null!=(i=m.arrow)&&i.alignmentOffset)return{};const E=a(o),P=a(u)===u,k=await(null==y.isRTL?void 0:y.isRTL(d.floating)),O=v||(P||!R?[s(u)]:r(u));v||"none"===b||O.push(...c(u,R,b,k));const D=[u,...O],T=await x(n,A),L=[];let B=(null==(l=m.flip)?void 0:l.overflows)||[];if(p&&L.push(T[E]),w){const e=f(o,g,k);L.push(T[e[0]],T[e[1]])}if(B=[...B,{placement:o,overflows:L}],!L.every((e=>e<=0))){var S,j;const e=((null==(S=m.flip)?void 0:S.index)||0)+1,t=D[e];if(t)return{data:{index:e,overflows:B},reset:{placement:t}};let n=null==(j=B.filter((e=>e.overflows[0]<=0)).sort(((e,t)=>e.overflows[1]-t.overflows[1]))[0])?void 0:j.placement;if(!n)switch(h){case"bestFit":{var C;const e=null==(C=B.map((e=>[e.placement,e.overflows.filter((e=>e>0)).reduce(((e,t)=>e+t),0)])).sort(((e,t)=>e[1]-t[1]))[0])?void 0:C[0];e&&(n=e);break}case"initialPlacement":n=u}if(o!==n)return{reset:{placement:n}}}return{}}}};const h=function(t){return void 0===t&&(t=0),{name:"offset",options:t,async fn(n){var o,s;const{x:r,y:c,placement:f,middlewareData:m}=n,g=await async function(t,n){const{placement:o,platform:s,elements:r}=t,c=await(null==s.isRTL?void 0:s.isRTL(r.floating)),f=a(o),m=i(o),g="y"===l(o),u=["left","top"].includes(f)?-1:1,y=c&&g?-1:1,d=e(n,t);let{mainAxis:p,crossAxis:x,alignmentAxis:w}="number"==typeof d?{mainAxis:d,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...d};return m&&"number"==typeof w&&(x="end"===m?-1*w:w),g?{x:x*y,y:p*u}:{x:p*u,y:x*y}}(n,t);return f===(null==(o=m.offset)?void 0:o.placement)&&null!=(s=m.arrow)&&s.alignmentOffset?{}:{x:r+g.x,y:c+g.y,data:{...g,placement:f}}}}},b=function(t){return void 0===t&&(t={}),{name:"shift",options:t,async fn(n){const{x:i,y:o,placement:s}=n,{mainAxis:r=!0,crossAxis:c=!1,limiter:f={fn:e=>{let{x:t,y:n}=e;return{x:t,y:n}}},...g}=e(t,n),u={x:i,y:o},d=await x(n,g),p=l(a(s)),w=y(p);let v=u[w],h=u[p];if(r){const e="y"===w?"bottom":"right",t=v+d["y"===w?"top":"left"],n=v-d[e];v=m(t,v,n)}if(c){const e="y"===p?"bottom":"right",t=h+d["y"===p?"top":"left"],n=h-d[e];h=m(t,h,n)}const b=f.fn({...n,[w]:v,[p]:h});return{...b,data:{x:b.x-i,y:b.y-o}}}}};export{w as a,p as c,x as d,v as f,h as o,b as s};
